##### Android 内存泄露

内存泄露原因:
一、Handler 引起的内存泄漏。
解决:将 Handler 声明为静态内部类，就不会持有外部类 SecondActivity 的引用，其生命周 期就和外部类无关，
如果 Handler 里面需要 context 的话，可以通过弱引用方式引用外部类.

二、单例模式引起的内存泄漏。
解决:Context 是 ApplicationContext，由于 ApplicationContext 的生命周期是和 app 一致的， 不会导致内存泄漏.

三、**非静态内部类**创建**静态实例**引起的内存泄漏。 
解决:把内部类修改为静态的就可以避免内存泄漏了.

四、**非静态匿名内部类**引起的内存泄漏。
解决:将匿名内部类设置为静态的。

五、注册/反注册未成对使用引起的内存泄漏。
注册广播接受器、EventBus 等，记得解绑。

六、资源对象没有关闭引起的内存泄漏。
在这些资源不使用的时候，记得调用相应的类似 close()、destroy()、recycler()、release ()等方法释放。

七、集合对象没有及时清理引起的内存泄漏。
通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不 再被引用。


Android UI 适配
字体使用 sp,使用 dp，
多使用 match_parent，wrap_content，weight 
图片资源，不同图片的的分辨率，放在相应的文件夹下
使用百分比


##### app 优化
- App 启动优化
Application 的 onCreate(特别是第三方 SDK 初始化)，首屏 Activity 的渲染都不要进行耗时操
作，如果有，就可以放到子线程或者 IntentService 中.

- 布局优化
尽量不要过于复杂的嵌套。可以使用`<include>，<merge>，<ViewStub>`
	
- 响应优化
Android 系统每隔 16ms 会发出 VSYNC 信号重绘我们的界面(Activity)。
	页面卡顿的原因:
(1)过于复杂的布局.
(2)UI 线程的复杂运算
(3)频繁的 GC, a.内存抖动, 即大量的对象被创建又在短时间内马上 被释放; b.瞬间产生大量的对象会严重占用内存区域。

- 内存优化
参考内存泄露

- 电池使用优化
(1)优化网络请求
(2)定位中使用 GPS, 请记得及时关闭

- 网络优化
API 设计:App 与 Server 之间的 API 设计要考虑网络请求的频次, 资源的状态等. 以便 App 可以以较少的请求来完成业务需求和界面的展示.
Gzip 压缩:使用 Gzip 来压缩 request 和 response, 减少传输数据量, 从而减少流量消耗.
图片的 Size:可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片,避免浪费.
网络缓存:适当的缓存, 既可以让我们的应用看起来更快, 也能避免一些不必要的流量消耗.


##### JAVA GC 原理
垃圾收集算法的核心思想是:对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配；如果对象正在被引用，那么称其为存活对象。

##### ANR
ANR 全名 Application Not Responding, 也就是"应用无响应". 
当操作在一段时间内系统无法处理时, 系统层面会弹出上图那样的 ANR 对话框.

产生:
(1)5s 内无法响应用户输入事件(例如键盘输入, 触摸屏幕等).
(2)BroadcastReceiver 在 10s 内无法结束
(3)Service 20s 内无法结束(低概率)

解决方式:
(1)不要在主线程中做耗时的操作，而应放在子线程中来实现。
onCreate()和 onResume() 里尽可能少的去做创建操作。
(2)应用程序应该避免在 BroadcastReceiver 里做耗时的操作或计算。
(3)避免在 Intent Receiver 里启动一个 Activity，
因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。
(4)service 是运行在主线程的，所以在 service 中做耗时操作，必须要放在子线程中。
