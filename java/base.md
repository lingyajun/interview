1、**java 中==和 equals 和 hashCode 的区别**
1) == 若是基本数据类型比较，是比较值，若是引用类型，则比较的是他们在内存中的存放地址。
对象是存放在堆中，栈中存放的对象的引用，所以==是对栈中的值进行比较，若 返回 true 代表变量的内存地址相等;

2) equals 是 Object 类中的方法，Object 类的 equals 方法用于判断对象的内存地址引用 是不是同一个地址(是不是同一个对象)。
若是类中覆盖了 equals 方法，就要根据具体代 码来确定。

3) hashCode()计算出对象实例的哈希码，在对象进行散列时作为 key 存入。
在批量的对象比较中，hashCode 比较要比 equals 快。

4) equals 与 hashCode 方法关系:hashCode()是一个本地方法，实现是根据本地机器上关的。。equals()相等的对象， hashCode()也一定相等;hashCode()不等，equals()一定也不等;hashCode()相等，equals() 可能相等，也可能不等。「方法可能被覆盖重写」


7 、**抽象类的意义**
抽象类是用来提供子类的通用性，用来创建继承层级里子类的模板，
减少代码编写，有利于 代码规范化。

10、**进程和线程的区别**
$进程$: 具有一定独立功能的程序，
是系统进行资源分配和调度运行的基本单位。

$线程$:进程的一个实体，是 CPU 调度的基本单位，也是进程中执行运算的最小单位，即执行 处理机调度的基本单位，
如果把进程理解为逻辑上操作系统所完成的任务，线程则表示完成 该任务的许多可能的子任务之一。

关系:一个进程可有多个线程，至少一个;一个线程只能属于一个进程。
同一进程的所有线程共享该进程的所有资源。不同进程的线程间要利用消息通信方式实现同步。

区别:进程有独立的地址空间，而多个线程共享内存;
进程具有一个独立功能的程序，线程不能独立运行，必须依存于应用程序中;

11、**final，finally，finalize**的区别
$final$:变量、类、方法的修饰符，被 final 修饰的类不能被继承，变量或方法被 final 修饰 则不能被修改和重写。
$finally$: 异常处理时提供 finally 块来执行清除操作，不管有没有异常抛出，此处代码都会 被执行。
如果 try 语句块中包含 return 语句，finally 语句块是在 return 之后运行;
$finalize$:Object 类中定义的方法，若子类覆盖了 finalize()方法，在在垃圾收集器将对象 从内存中清除前，会执行该方法，确定对象是否会被回收。

12、序列化 Serializable 和 Parcelable 的区别
$序列化$:将一个对象转换成可存储或可传输的状态，
序列化后的对象可以在网络上传输，也可以存储到本地，或实现跨进程传输;

区别:
Serializable 在序列化时会产生大量临时变量，引起频繁 GC。
Serializable 本质上使 用了反射，序列化过程慢。
Parcelable 不能将数据存储在磁盘上，在外界变化时，它不能 很好的保证数据的持续性。

选择原则:
若仅在内存中使用，如 activity\service 间传递对象，优先使用 Parcelable，它性能高。
若是持久化操作，优先使用 Serializable

注意:
静态成员变量属于类，不属于对象，固不会参与序列化的过程;
用 transient 关键字编辑的成员变量不会参与序列化过程;
通过重写 writeObject()和 readObject()方法来 重写系统默认的序列化和反序列化。

> 谈谈对 kotlin 的理解
特点:
1) 代码量少且代码末尾没有分号;
2) 空类型安全(编译期处理了各种 null 情况， 避免执行时异常);
3) 函数式的，可使用 lambda 表达式;
4) 可扩展方法(可扩展任意 类的的属性);
5) 互操作性强，可以在一个项目中使用 kotlin 和 java 两种语言混合开发;

**简述 java 垃圾回收机制**
在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。
在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在$虚拟机空闲或者当前堆内存不足$时，才会触发执行，扫面那些没有被任何引用的对象，并将 它们添加到要回收的集合中，进行回收。


